#!/usr/bin/env python
# coding: utf-8

# In[1]:

import re
from collections import defaultdict
import json
import os
from lxml import html
import requests
import xml.etree.ElementTree as ET
import gzip
from bs4 import BeautifulSoup
import io
from urllib.request import urlopen
import collections 
from urllib.parse import urlparse
import pandas as pd


# In[7]:





# In[4]:


import shutil
shutil.rmtree('data_injection/apk/art_and_design/data_injection')


# In[3]:


basepath='/home/sic100/data_injection/'
if not os.path.exists(basepath):
    os.mkdir(basepath)


# In[4]:


#dir "all_smali_code" stores various folders, each one representing a category of hundreds of apps
#each folder in one category directory will be named by the name of the app

basedir=os.path.join(basepath, "smali")
basedir
if not os.path.exists(basedir):
    os.mkdir(basedir)

apkdir=os.path.join(basepath, 'apk')
if not os.path.exists(apkdir):
    os.mkdir(apkdir)


# In[5]:


# parse sitemap and get url
sitemap_url="https://apkpure.com/sitemap.xml"
def get_url_from_sitemap(sitemap_url): 
    sitemap=requests.get("https://apkpure.com/sitemap.xml")
    tree = html.fromstring(sitemap.content)
    url = tree.xpath('//loc/text()')
    return url


# In[6]:


url=get_url_from_sitemap(sitemap_url)
url


# In[7]:


#parse each url and get the category for each app
#store the urls according to the catefores into a dictionary

def categorize_url(url_list):
    url_dict=defaultdict(list)
    category_pattern='https://apkpure.com/sitemaps/(.+)(-\d+)?.xml.gz'
    for i in url:
        path=urlparse(i).path
        category=re.match("/sitemaps/(\w+)(-\d+)?.xml.gz", path).group(1)
        if category not in url_dict:
            url_dict[category]=[i]
        else:
            url_dict[category].append(i)
    return url_dict

   


# In[8]:


url_dict=categorize_url(url)
url_dict


# In[9]:


url_dict.keys()


# In[10]:


# url = 'https://apkpure.com/sitemaps/art_and_design-35.xml.gz'


# In[11]:


#I need to append selected ulrs for each category in url_dict in to the function to get to website for downloading apk
# input is url_dict



def download_gzip_link(url_dict):
    link_dict=defaultdict(list)
    #I only choose the meaningful categories, starting from art_and_design
    for i in list(url_dict.keys())[4:]:
        pattern='https://apkpure.com/{}'.format(i)+'(.+)?'
        ############################
        #for cumputation, I only select 2 links for each category#
        for url in url_dict[i][:2]:
            r = requests.get(url)
            with gzip.GzipFile(fileobj=io.BytesIO(r.content)) as f:
                result = f.read()
                soup = BeautifulSoup(result, 'xml')
                x_default=soup.find_all("xhtml:link", {"hreflang":  "en"})
                result=[x_default[index].get('href') for index in range(len(x_default)) if index%2==0 and                       not re.match(pattern, x_default[index].get('href'))]
                for k in result:
                    link_dict[i].append(k)
    with open(os.path.join(basepath, 'link_dict.json'), 'w') as outfile:
        json.dump(link_dict, outfile)
    return 


# In[ ]:


link_dict=download_gzip_link(url_dict)
link_dict


# In[16]:


with open(os.path.join(basepath, 'link_dict.json'), 'w') as outfile:
        json.dump(link_dict, outfile)


# In[19]:


link_dict['art_and_design']


# In[4]:


#each app has two links starting with https://apkpure.com or https://m.apkpure.com
#I will only extract the download link from the https://apkpure.com website, whose index is even
# download link is under <div class='details'--> <div class='down-wrap' --> <div class='down' 
#input: index of link is even
def get_download_link():
    basepath='/home/sic100/data_injection/'
    with open(os.path.join(basepath, 'link_dict.json'), 'r') as outfile:
        link_dict = json.load(outfile)
        
    basepath='/home/sic100/data_injection/'
    app_path=os.path.join(basepath, 'app')
    if not os.path.exists(app_path):
        os.mkdir(app_path)
    
    app_info_container=[]
    link_dict_keys=list(link_dict.keys())
    download_links_ls=defaultdict(list)
    for key in link_dict_keys:
        for link in link_dict[key][:10]:   
            try:
                app_name=re.match('(https://apkpure.com/(.+))/', link).group(2)
                resp = requests.get(link)
                data = resp.content
                filtered = BeautifulSoup(data).find_all("a", class_="da", href=True)
                x=filtered[0]['href']
                download_link="https://apkpure.com{}".format(x)

                resp = requests.get(download_link)
                data = resp.content
                filtered = BeautifulSoup(data).find_all("a", class_='ga', href=True)[0]['href']

                download_links_ls[key].append(filtered)
                data={}
                data['app_name']=app_name
                data['download_link']=filtered
                data['category']=key
                app_info_container.append(data)
            except:
                pass
    with open(os.path.join(app_path, 'app_info.json'), 'w') as outfile:
        json.dump(app_info_container, outfile)
    
    return download_links_ls
    
        


# In[5]:


download_links_ls=get_download_link()


# In[10]:


basepath='/home/sic100/data_injection/'
with open(os.path.join(basepath,'app', 'app_info.json'), 'r') as outfile:
        dic = json.load(outfile)


# In[11]:


dic


# In[36]:


### input: app_info.json
def get_apk_from_download_link():
    basepath='/home/sic100/data_injection/'
    apk_dir=os.path.join(basepath, 'apk')
    if not os.path.exists(apk_dir):
        os.mkdir(apk_dir)
    app_info_json_path=os.path.join(basepath, 'app/app_info.json')
    with open(app_info_json_path, 'r') as inputfile:
        app_info=json.load(inputfile)
        for app in app_info:
            app_name=app['app_name']
            print(app_name)
            download_link=app['download_link']
            category=app['category']
            category_dir=os.path.join(apk_dir, category)
            if not os.path.exists(category_dir):
                os.mkdir(category_dir)
            app_apk_dir=os.path.join(category_dir, app_name)+'.apk'
            resp = requests.get(download_link)
            with open(app_apk_dir, 'wb') as fh:
                data = resp.content
                fh.write(data)

    


# In[37]:


get_apk_from_download_link()


# In[34]:


import subprocess
download_link = 'https://download.apkpure.com/b/apk/Y29tLnN3ZWVmaXRzdHVkaW9zLmRyYXdmbG93ZXJzXzEyXzg5NzAzYWY?_fn=SG93IHRvIERyYXcgRmxvd2Vyc192NS4xX2Fwa3B1cmUuY29tLmFwaw&k=febd7ac75a2ecd307b1b44f918f62c285e6bcb8c&as=25b52d3d78b97b3996e288efc3d38f475e692904&_p=Y29tLnN3ZWVmaXRzdHVkaW9zLmRyYXdmbG93ZXJz&c=1%7CART_AND_DESIGN%7CZGV2PVN3ZWVmaXQlMjBTdHVkaW9zJnQ9YXBrJnM9MTM3NzY2NzMmdm49NS4xJnZjPTEy'
resp = requests.get(download_link)
app_apk_dir = os.path.join(basepath, 'apk/art_and_design/how-to-draw-flowers.apk')
print(app_apk_dir)
with open(app_apk_dir, 'wb') as fh:
        data = resp.content
        fh.write(data)


# In[35]:


bashCommand = "apktool d $app_apk_dir "
os.system (bashCommand)


# In[ ]:





# In[257]:


### convert apk to smali
apk_dir='/Users/chensizhu/Desktop/data injection/apk'
smali_dir='/Users/chensizhu/Desktop/data injection/smali'
apk_dir


# In[ ]:





# In[10]:


get_ipython().run_cell_magic('bash', '', '\nfor dir in data_injection/apk/*/;\ndo\n    for file in $dir/*.apk;\n    do \n        name=${file##*./};\n        f=${name%.*};\n        apktool d $file -o $f;\n    done \ndone')


# In[ ]:





# In[ ]:





# In[13]:


l='invoke-static {}, Lcom/facebook/ads/internal/protocol/AdPlacementType;->A01()V'


# In[ ]:





# In[ ]:





# In[10]:





# In[6]:


def extract_features_for_app():
    apk_address='./data_injection/apk'
    basepath=os.getcwd()
    ass2_json=os.path.join(basepath, 'ass2_json')
    if not os.path.exists(ass2_json):
            os.mkdir(ass2_json)
    
    category_pattern='/(\w+)$'
    method_pattern='^.method'
    end_method_pattern='^.end\smethod'
    app_name_pattern='.+/(.+)$'
    target_line_pattern='invoke-.+'
    invoke_method_pattern='(invoke-(direct|static|virtual|super|interface))'
    package_pattern='}, (.+)->'
    return_package_pattern='\(.+'
#     API_call_pattern='}, (.+)$'
    API_P1=', \[?\[?(L.+;->.+)\('
    API_P2=', \[?\[?([A-Z]->.+)\('  

    
#app_smali_folder_dir 
    API_invoke_methods=defaultdict(list)
    API_package=defaultdict(list)
    app_API=defaultdict(list)
    API_codeblocks=[]
    all_API=[]
    
    
    ls_API_invoke_methods=[]
    ls_API_package=[]
    ls_API=[]
    ls_API_codeblocks=[]
    ls_all_API=[]
    ls_app=[]
    ls_return_packages=[]
    ls_category=[]
    codeblock_id=0
    app_id=0
    app_id_dic=dict()
    
    for cat in os.listdir(apk_address):
        print(cat)
        cat_dir=os.path.join(apk_address, cat)
        if os.path.isdir(cat_dir):
            #### for computation, I only take 2
            app_smali_folder_path=[os.path.join(cat_dir, smali_class) for smali_class in os.listdir(cat_dir)                                   if not smali_class.endswith('.apk') and os.path.isdir(os.path.join(cat_dir,                                                                                                  smali_class))]
            for app_smali_folder_dir in app_smali_folder_path:
                size=os.stat(app_smali_folder_dir).st_size
                
                app_name=re.findall(app_name_pattern,app_smali_folder_dir)[0]
                if size>=9:
                    print('skip    '+app_name)
                    continue
                app_id_dic[app_id]=app_name
                app_id+=1
                print('collection    '+app_name)
                add_line=False
                for dirpath, dirname, files in os.walk(app_smali_folder_dir):
                    for file in files:
                        if file.endswith('.smali'):
                            with open(os.path.join(dirpath, file), 'r') as auto:
                                with open(auto.name, 'r') as f:
                                    for i in f.readlines():
                                        start_method=re.match(method_pattern, i)
                                        end_method=re.match(end_method_pattern, i)
                                        target_line=re.findall(target_line_pattern, i)
                                        if start_method:
                                            add_line=True
                                            API_single_codeblock=[]
                                        if end_method:
                                            add_line=False
                                            API_codeblocks.append(API_single_codeblock)
                                        if add_line==True:
                                            #extract invoke method, API calls once the line is target line within the code clocks
                                            if len(target_line)!=0:
                                                try:
                                                    invoke_method=re.findall(invoke_method_pattern, i)[0][0]                                                
                                                    package=re.findall(package_pattern, i)[0]
                                                    API_call_ls=re.findall(API_P1, i)+re.findall(API_P2, i)
                                                    API_call=API_call_ls[0]
                                                    return_package=re.findall(return_package_pattern, i)[0]
                                                except:
                                                    print(i)
                                                    
                                                ls_category.append(cat)
                                                ls_API_invoke_methods.append(invoke_method)                                             
                                                ls_API_package.append(package)
                                                ls_API_codeblocks.append(codeblock_id)
                                                ls_API.append(API_call)
                                                ls_return_packages.append(return_package)
                                                ls_app.append(app_name)
                                                
                                                
                                                if API_call not in API_invoke_methods[invoke_method]:
                                                    API_invoke_methods[invoke_method].append(API_call)
                                                else:
                                                    pass
                                                if API_call not in API_package[package]:
                                                    API_package[package].append(API_call)
                                                else:
                                                    pass
                                                if API_call not in API_single_codeblock:
                                                    API_single_codeblock.append(API_call)
                                                else:
                                                    pass
                                                app_API[app_name].append(API_call)
                                                if API_call not in all_API: 
                                                    all_API.append(API_call)
    
    ls_output=[ls_API_package,ls_API_invoke_methods,ls_API,ls_API_codeblocks,               ls_app, ls_all_API, app_id_dic, ls_category]
    output=[API_package,API_invoke_methods,app_API,API_codeblocks, all_API]
#     output_name=['API_package', 'API_invoke_methods', 'app_API', 'API_codeblocks', 'all_API']
#     df_data=pd.DataFrame({'API_package': ls_output[0], 'API_invoke_methods': ls_output[1], \
#                           'API': ls_output[2], 'API_codeblocks': ls_output[3], 'app': ls_output[4],\
#                           'category': ls_output[-1]
#                          })
#     df_data.to_csv('data_injection/benigh.csv')
    

    return output, ls_output


# In[7]:


get_ipython().run_line_magic('time', 'output, ls_output = extract_features_for_app()')


# In[8]:


df_data=pd.DataFrame({'API_package': ls_output[0], 'API_invoke_methods': ls_output[1],                       'API': ls_output[2], 'API_codeblocks': ls_output[3], 'app': ls_output[4],                      'category': ls_output[-1]})
df_data.to_csv('./data_injection/benign.csv')


# In[9]:


output_name=['API_package', 'API_invoke_methods', 'app_API', 'API_codeblocks', 'all_API']
for i in range(len(output)):
    data=output[i]
    with open('./data_injection/b'+output_name[i]+'.json', 'w+') as f:
        json.dump(data, f)
        print(output_name[i], "->complete")


# In[10]:


df_data.shape


# In[ ]:





# In[ ]:





# In[ ]:





# In[ ]:





# In[ ]:





# In[ ]:





# In[ ]:





# In[ ]:





# In[ ]:





# In[ ]:





# In[ ]:





# In[ ]:





# In[407]:


#for every smali code, I extract all the lines within each blocks.
#appName: appName


#input: apk_address='/Users/chensizhu/Desktop/data injection/apk'
def extract_features_for_app(apk_address):
    method_pattern='^.method'
    end_method_pattern='^.end\smethod'
    app_name_pattern='.+apk/.+/(.+)'
    new_line_pattern='[\r\n]'
    target_line_pattern='invoke-.+'
    invoke_method_pattern='(invoke-(direct|static|virtual|super|interface))'
    package_pattern='}, (.+)->'
    API_call_pattern='}, (.+)$'
    
#app_smali_folder_dir 
    API_invoke_methods=defaultdict(list)
    API_package=defaultdict(list)
    app_API=defaultdict(list)
    API_codeblocks=[]
    all_API=[]
    for cat in os.listdir(apk_address):
        cat_dir=os.path.join(apk_address, cat)
        if os.path.isdir(cat_dir):
            #### for computation, I only take 2
            app_smali_folder_path=[os.path.join(cat_dir, smali_class) for smali_class in os.listdir(cat_dir)                                   if not smali_class.endswith('.apk') and os.path.isdir(os.path.join(cat_dir,                                                                                                      smali_class))]

            for app_smali_folder_dir in app_smali_folder_path:
                app_name=re.match(app_name_pattern,app_smali_folder_dir).group(1)
                print(app_name)
                add_line=False
                for dirpath, dirname, files in os.walk(app_smali_folder_dir):
                    for file in files:
                        if file.endswith('.smali'):
                            with open(os.path.join(dirpath, file), 'r+') as auto:
                                with open(auto.name, 'r+') as f:

                                    for i in f.readlines():
                                        new_line=re.match(new_line_pattern, i)
                                        start_method=re.match(method_pattern, i)
                                        end_method=re.match(end_method_pattern, i)
                                        target_line=re.findall(target_line_pattern, i)
                                        

                                        if new_line:
                                            continue
                                        if start_method:
                                            add_line=True
                                            API_single_codeblock=[]
                                        if end_method:
                                            add_line=False
                                            API_codeblocks.append(API_single_codeblock)
                                        if add_line==True:
                                            #extract invoke method, API calls once the line is target line within the code clocks
                                            if len(target_line)!=0:
                                                #extract invoke_method+package+API calls
                                                #method_type is among 'invoke-static', 'invoke-virtual', 
                                                #'invoke-direct', 'invoke-super', 'invoke-interface'
                                                invoke_method=re.findall(invoke_method_pattern, i)[0][0]
                                                                                                
                                                package=re.findall(package_pattern, i)[0]
                                                API_call=re.findall(API_call_pattern, i)[0]
                                                if invoke_method==None or package==None or API_call==None:
                                                    print(i)
                                                if API_call not in API_invoke_methods[invoke_method]:
                                                    API_invoke_methods[invoke_method].append(API_call)
                                                else:
                                                    continue
                                                #### API-package
                                                if API_call not in API_package[package]:
                                                    API_package[package].append(API_call)
                                                else:
                                                    continue
                                                #### API_call in single code block
                                                if API_call not in API_single_codeblock:
                                                    API_single_codeblock.append(API_call)
                                                else:
                                                    continue
                                                #### app-API
                                                app_API[app_name].append(API_call)
                                                if API_call not in all_API: 
                                                    all_API.append(API_call)
                                            
    output=[API_package,API_invoke_methods,app_API,API_codeblocks, all_API]
    output_name=['API_package', 'API_invoke_methods', 'app_API', 'API_codeblocks', 'all_API']
    for i in range(len(output)):
        data=output[i]
        with open('/Users/chensizhu/Desktop/data injection/smali/'+output_name[i]+'.json', 'w+') as f:
            json.dump(data, f)
            print(output_name[i], "->complete")
    return 
        


        
    



# In[ ]:


def extract_features_for_app(apk_address):
    
    basepath=os.getcwd()
    ass2_json=os.path.join(basepath, 'ass2_json')
    if not os.path.exists(ass2_json):
            os.mkdir(ass2_json)
        
    method_pattern='^.method'
    end_method_pattern='^.end\smethod'
    app_name_pattern='.+/(.+)apk'
    target_line_pattern='invoke-.+'
    invoke_method_pattern='(invoke-(direct|static|virtual|super|interface))'
    package_pattern='}, (.+)->'
#     API_call_pattern='}, (.+)$'
    API_P1=', \[?\[?(L.+;->.+)\('
    API_P2=', \[?\[?([A-Z]->.+)\('  
    return_package_pattern='\(.+'
    
    ls=['/datasets/dsc180a-wi20-public/Malware/testing/benign/Microsoft Word Write Edit Share Docs on the Go_v16.0.12430.20120_apkpure.com/smali']

    
#app_smali_folder_dir 
    API_invoke_methods=[]
    API_package=[]
    API=[]
    API_codeblocks=[]
    all_API=[]
    app=[]
    return_packages=[]
    codeblock_id=0
    app_id=0
    app_id_dic=dict()
    

    for cat in os.listdir(apk_address):######
        cat_dir=os.path.join(apk_address, cat)
        if os.path.isdir(cat_dir):
            #### for computation, I only take 2
            app_smali_folder_path=[os.path.join(cat_dir, smali_class) for smali_class in os.listdir(cat_dir)                                   if not smali_class.endswith('.apk') and os.path.isdir(os.path.join(cat_dir,                                                                                                      smali_class))]
            print(app_smali_folder_path)
            for app_smali_folder_dir in app_smali_folder_path:
                app_name=re.findall(app_name_pattern,app_smali_folder_dir)[0]
                app_id_dic[app_id]=app_name
                app_id+=1
                add_line=False
                for dirpath, dirname, files in os.walk(app_smali_folder_dir):
                    for file in files:
                        if file.endswith('.smali'):
                            with open(os.path.join(dirpath, file), 'r') as auto:
                                with open(auto.name, 'r') as f:
                                    for i in f.readlines():
                                        start_method=re.match(method_pattern, i)
                                        end_method=re.match(end_method_pattern, i)
                                        target_line=re.findall(target_line_pattern, i)
                                        if start_method:
                                            add_line=True
                                            codeblock_id+=1
                                        if end_method:
                                            add_line=False
                                        if add_line==True:
                                            #extract invoke method, API calls once the line is target line within the code clocks
                                            if len(target_line)!=0:
                                                #extract invoke_method+package+API calls
                                                #method_type is among 'invoke-static', 'invoke-virtual', 
                                                #'invoke-direct', 'invoke-super', 'invoke-interface'
                                                try:
                                                    invoke_method=re.findall(invoke_method_pattern, i)[0][0]                                                
                                                    package=re.findall(package_pattern, i)[0]
                                                    API_call_ls=re.findall(API_P1, i)+re.findall(API_P2, i)
                                                    API_call=API_call_ls[0]
                                                    return_package=re.findall(return_package_pattern, i)[0]
                                                except:
                                                    print(i)
                                                
                                                API_invoke_methods.append(invoke_method)                                             
                                                API_package.append(package)
                                                API_codeblocks.append(codeblock_id)
                                                API.append(API_call)
                                                return_packages.append(return_package)
                                                app.append(app_name)
                                                
                                                if API_call not in all_API: 
                                                    all_API.append(API_call)
                    
                                        
    output=[API_package,API_invoke_methods,API,API_codeblocks, app, all_API, app_id_dic]
    output_name=['API_package', 'API_invoke_methods', 'API', 'API_codeblocks', 'app', 'all_API', 'app_id_dicdf']
#     for i in range(len(output)):
#         data=output[i]
#         with open(ass2_json+'/'+output_name[i]+'.json', 'w+') as f:
#             json.dump(data, f)
#             print(output_name[i], "->complete")
    return output


# In[408]:


apk_address='/Users/chensizhu/Desktop/data injection/apk'
out_example=extract_features_for_app(apk_address)

import numpy as np
import re
from collections import defaultdict
import json
import os
from sklearn.preprocessing import MultiLabelBinarizer
import pandas as pd
from scipy import sparse
from networkx import convert_matrix
import networkx as nx
import matplotlib.pyplot as plt


# In[2]:



mdf = pd.read_csv('./data_injection/malware.csv')
bdf = pd.read_csv('./data_injection/benign.csv')
path='./data_injection/API_package'+'.json'
with open(path, 'r') as inputfile:
    mAPI_package=json.load(inputfile)
path='./data_injection/API_invoke_methods'+'.json'
with open(path, 'r') as inputfile:
    mAPI_invoke_methods=json.load(inputfile)
path='./data_injection/app_API'+'.json'
with open(path, 'r') as inputfile:
    mapp_API=json.load(inputfile)
path='./data_injection/API_codeblocks'+'.json'
with open(path, 'r') as inputfile:
    mAPI_codeblocks=json.load(inputfile)  
path='./data_injection/all_API'+'.json'
with open(path, 'r') as inputfile:
    mall_API=json.load(inputfile)
path='./data_injection/bAPI_package'+'.json'
with open(path, 'r') as inputfile:
    bAPI_package=json.load(inputfile)
path='./data_injection/bAPI_invoke_methods'+'.json'
with open(path, 'r') as inputfile:
    bAPI_invoke_methods=json.load(inputfile)
path='./data_injection/bapp_API'+'.json'
with open(path, 'r') as inputfile:
    bapp_API=json.load(inputfile)
path='./data_injection/bAPI_codeblocks'+'.json'
with open(path, 'r') as inputfile:
    bAPI_codeblocks=json.load(inputfile)  
path='./data_injection/ball_API'+'.json'
with open(path, 'r') as inputfile:
    ball_API=json.load(inputfile)


# In[ ]:





# In[ ]:





# In[ ]:





# In[3]:


def get_app_API(bapp_API, mapp_API):
    app_API={**bapp_API, **mapp_API}
    return app_API
def get_all_API(ball_API, mall_API):
    all_API=set(ball_API+mall_API)
    m = mdf['API'].value_counts().to_frame('count_API').sort_values('count_API', ascending = False)
    mAPI = m.loc[m['count_API']==1].index.tolist()
    b = bdf['API'].value_counts().to_frame('count_API').sort_values('count_API', ascending = False)
    bAPI = b.loc[b['count_API']==1].index.tolist()
    oneAPI = set(mAPI + bAPI)
    all_API = list(all_API-oneAPI)
    return all_API
def get_API_invoke_methods(bAPI_invoke_methods, mAPI_invoke_methods):
    for i in bAPI_invoke_methods:
        bls = bAPI_invoke_methods[i]
        mls = mAPI_invoke_methods[i]
        lst=list(set(bls+mls))
        bAPI_invoke_methods[i] = lst
    return bAPI_invoke_methods
def get_API_codeblocks(bAPI_codeblocks, mAPI_codeblocks):
    API_codeblocks = np.unique(bAPI_codeblocks+mAPI_codeblocks)
    return API_codeblocks
def get_API_package(bAPI_package, mAPI_package):
    keys = set(list(bAPI_package.keys())+list(mAPI_package.keys()))
    for i in keys:
        if i in mAPI_package and i in bAPI_package:
            bls = bAPI_package[i]
            mls = mAPI_package[i]
            lst = list(set(bls+mls))
            bAPI_package[i] = lst
        elif i not in bAPI_package and i in mAPI_package:
            bAPI_package[i] = mAPI_package[i]
            
    return bAPI_package
    
    

    


# In[4]:


all_API = get_all_API(ball_API, mall_API)


# In[5]:


app_API = get_app_API(bapp_API, mapp_API)


# In[6]:


API_codeblocks = get_API_codeblocks(bAPI_codeblocks, mAPI_codeblocks)


# In[7]:


API_package = get_API_package(bAPI_package, mAPI_package)


# In[8]:


API_invoke_methods = get_API_invoke_methods(bAPI_invoke_methods, mAPI_invoke_methods)


# In[9]:


def get_A(all_API, app_API):
    app_api_df=pd.DataFrame({'app': list(app_API.keys()), 'api list': list(app_API.values())})
    mlb = MultiLabelBinarizer()
    mlb.fit([all_API])
    one_hot=mlb.transform(app_api_df['api list'])
    A=pd.DataFrame(index=list(app_API.keys()), columns=all_API, data=one_hot)
    return A


# In[10]:


A = get_A(all_API, app_API)


# In[11]:


A.shape


# In[12]:


from sklearn.model_selection import train_test_split
from sklearn.svm import SVC


# In[13]:


label = [1]*52+[0]*53


# In[14]:


X_train, X_test, y_train, y_test = train_test_split(A, label, test_size = 1/3)


# In[15]:


def train(A):
    return A.dot(A.T)


# In[18]:


def test(A_train, A_test):
    return A_test.dot(A_train.T)


# In[21]:


Xt = train(X_train)


# In[22]:


Xt.shape


# In[23]:


Xtest = test(X_train, X_test) 


# In[24]:


Xtest.shape


# In[28]:


model = SVC(kernel='precomputed')
model.fit(Xt, y_train)


# In[29]:


model.score(Xtest, y_test)


# In[ ]:





# In[ ]:





# In[ ]:





# In[13]:


def get_I(API_invoke_methods, all_API):
    df=pd.DataFrame({'invoke_methods': list(API_invoke_methods.keys()), 'api list': list(API_invoke_methods.values())})
    mlb = MultiLabelBinarizer()
    mlb.fit([all_API])
    one_hot=mlb.transform(df['api list'])
    I=pd.DataFrame(index=list(API_invoke_methods.keys()), columns=all_API, data=one_hot)
    return I


# In[14]:


I = get_I(API_invoke_methods, all_API)


# In[15]:


I.head()


# In[ ]:





# In[ ]:





# In[ ]:



    
    
    
    


# In[16]:


def get_B(API_codeblocks, all_API):
    two_more=[x for x in API_codeblocks if len(x)>=2]
    mlb = MultiLabelBinarizer()
    mlb.fit([all_API])
    one_hot=mlb.transform(two_more)
    sparse_t=sparse.csr_matrix(one_hot)
    df_data=sparse_t.T.dot(sparse_t)
    df_data[df_data>1]=1
    df=df_data.todense()
    B=pd.DataFrame(index=all_API, columns=all_API, data=df)
    B.to_csv('./data_injection/B.csv')
    return B


# In[ ]:


get_ipython().run_line_magic('time', 'B = get_B(API_codeblocks, all_API)')


# In[ ]:


B.shape


# In[ ]:


B.head(10)


# In[20]:


B.values


# In[49]:


def get_P(API_package, all_API):
    mlb = MultiLabelBinarizer()
    mlb.fit([all_API])
    one_hot=mlb.transform(list(API_package.values()))
    sparse_t=sparse.csr_matrix(one_hot)
    df_data=sparse_t.T.dot(sparse_t)
    df_data[df_data>1]=1
    df=df_data.todense()
    P=pd.DataFrame(index=all_API, columns=all_API, data=df)
    return P


# In[51]:


get_ipython().run_line_magic('time', 'P = get_P(API_package, all_API)')


# In[53]:


P.head()


# In[64]:


def buidling_kernel(A, B, P, I):
    #AAT
    A_values=A.values
    sparse_A=sparse.csr_matrix(A_values)
    AAT=sparse_A.dot(sparse_A.T).todense()
    
    #ABAT
    B_values=B.values
    sparse_B=sparse.csr_matrix(B_values)
    ABAT=sparse_A.dot(sparse_B).dot(sparse_A.T).todense()
    
    
    #APAT
    P_values=P.values
    sparse_P=sparse.csr_matrix(P_values)
    APAT=sparse_A.dot(sparse_P).dot(sparse_A.T).todense()
    
    
    #APBPTAT
    APBPTAT=sparse_A.dot(sparse_P).dot(sparse_B).dot(sparse_P.T).dot(sparse_A.T)
    
    kernel=[AAT, ABAT, APAT, APBPTAT]
    return kernel


# In[ ]:


get_ipython().run_line_magic('time', 'kernel = buidling_kernel(A, B, P, I)')


# In[ ]:





# In[ ]:





# In[ ]:





# In[ ]:





# In[133]:


A_b['label']=[1]*A_b.shape[0]


# In[134]:


A_b


# In[135]:


from sklearn.svm import SVC
from sklearn.model_selection import train_test_split


# In[136]:


A=pd.concat([A_m,A_b], axis=0)


# In[137]:


A


# In[167]:


train, test = train_test_split(smaller_A, test_size=0.333)


# In[168]:


clf = SVC()
clf.fit(X=train.drop(columns=['label']), y=train['label'])


# In[172]:


prediction=clf.predict(test.drop(columns=['label']))


# In[173]:


score=sum([1 if prediction[i]==test['label'][i] else 0 for i in range(len(prediction))])/len(prediction)


# In[175]:


score


# In[ ]:





# In[ ]:




