#!/usr/bin/env python
# coding: utf-8

# In[3]:


import numpy as np
import re
from collections import defaultdict
import json
import os
from sklearn.preprocessing import MultiLabelBinarizer
import pandas as pd
from scipy import sparse
from networkx import convert_matrix
import networkx as nx
import matplotlib.pyplot as plt


# In[ ]:





# In[ ]:





# In[2]:


def extract_features_for_app(apk_address):
    
    basepath=os.getcwd()
    ass2_json=os.path.join(basepath, 'ass2_json')
    if not os.path.exists(ass2_json):
            os.mkdir(ass2_json)
        
    method_pattern='^.method'
    end_method_pattern='^.end\smethod'
    app_name_pattern='.+/(.+)apk'
    target_line_pattern='invoke-.+'
    invoke_method_pattern='(invoke-(direct|static|virtual|super|interface))'
    package_pattern='}, (.+)->'
#     API_call_pattern='}, (.+)$'
    API_P1=', \[?\[?(L.+;->.+)\('
    API_P2=', \[?\[?([A-Z]->.+)\('  

    
#app_smali_folder_dir 
    API_invoke_methods=defaultdict(list)
    API_package=defaultdict(list)
    app_API=defaultdict(list)
    API_codeblocks=[]
    all_API=[]
    for cat in os.listdir(apk_address):
        cat_dir=os.path.join(apk_address, cat)
        if os.path.isdir(cat_dir):
            #### for computation, I only take 2
            app_smali_folder_path=[os.path.join(cat_dir, smali_class) for smali_class in os.listdir(cat_dir)                                   if not smali_class.endswith('.apk') and os.path.isdir(os.path.join(cat_dir,                                                                                                      smali_class))]
            print(app_smali_folder_path)
            for app_smali_folder_dir in app_smali_folder_path:
                app_name=re.findall(app_name_pattern,app_smali_folder_dir)[0]
                print(app_name)
                add_line=False
                for dirpath, dirname, files in os.walk(app_smali_folder_dir):
                    for file in files:
                        if file.endswith('.smali'):
                            with open(os.path.join(dirpath, file), 'r') as auto:
                                with open(auto.name, 'r') as f:
                                    for i in f.readlines():
                                        start_method=re.match(method_pattern, i)
                                        end_method=re.match(end_method_pattern, i)
                                        target_line=re.findall(target_line_pattern, i)
                                        if start_method:
                                            add_line=True
                                            API_single_codeblock=[]
                                        if end_method:
                                            add_line=False
                                            API_codeblocks.append(API_single_codeblock)
                                        if add_line==True:
                                            #extract invoke method, API calls once the line is target line within the code clocks
                                            if len(target_line)!=0:
                                                #extract invoke_method+package+API calls
                                                #method_type is among 'invoke-static', 'invoke-virtual', 
                                                #'invoke-direct', 'invoke-super', 'invoke-interface'
                                                try:
                                                    invoke_method=re.findall(invoke_method_pattern, i)[0][0]                                                
                                                    package=re.findall(package_pattern, i)[0]
                                                    API_call_ls=re.findall(API_P1, i)+re.findall(API_P2, i)
                                                    API_call=API_call_ls[0]
                                                except:
                                                    print(i)
                                                if API_call not in API_invoke_methods[invoke_method]:
                                                    API_invoke_methods[invoke_method].append(API_call)
                                                else:
                                                    pass
                                                #### API-package
                                                if API_call not in API_package[package]:
                                                    API_package[package].append(API_call)
                                                else:
                                                    pass
                                                #### API_call in single code block
                                                if API_call not in API_single_codeblock:
                                                    API_single_codeblock.append(API_call)
                                                else:
                                                    pass
                                                #### app-API
                                                app_API[app_name].append(API_call)
                                                if API_call not in all_API: 
                                                    all_API.append(API_call)
    output=[API_package,API_invoke_methods,app_API,API_codeblocks, all_API]
    output_name=['API_package', 'API_invoke_methods', 'app_API', 'API_codeblocks', 'all_API']
#     for i in range(len(output)):
#         data=output[i]
#         with open(ass2_json+'/'+output_name[i]+'.json', 'w+') as f:
#             json.dump(data, f)
#             print(output_name[i], "->complete")
    return output


# In[263]:


output=extract_features_for_app(apk_address)


# In[264]:


apk_address='/datasets/dsc180a-wi20-public/Malware/testing/benign'


# In[265]:


apk_address='/datasets/dsc180a-wi20-public/Malware/testing/'
os.listdir(apk_address)


# In[266]:


ass2_json='/home/sic100/ass2_json'


# In[267]:



output_name=['API_package', 'API_invoke_methods', 'app_API', 'API_codeblocks', 'all_API']
for i in range(len(output)):
    data=output[i]
    with open(ass2_json+'/'+output_name[i]+'.json', 'w+') as f:
        json.dump(data, f)
        print(output_name[i], "->complete")


# In[6]:


path='./ass2_json/API_package'+'.json'
with open(path, 'r') as inputfile:
    API_package=json.load(inputfile)
path='./ass2_json/API_invoke_methods'+'.json'
with open(path, 'r') as inputfile:
    API_invoke_methods=json.load(inputfile)
path='./ass2_json/app_API'+'.json'
with open(path, 'r') as inputfile:
    app_API=json.load(inputfile)
path='./ass2_json/API_codeblocks'+'.json'
with open(path, 'r') as inputfile:
    API_codeblocks=json.load(inputfile)  
path='./ass2_json/all_API'+'.json'
with open(path, 'r') as inputfile:
    all_API=json.load(inputfile)


# In[73]:


path='./ass2_mal_json/API_package'+'.json'
with open(path, 'r') as inputfile:
    API_package_m=json.load(inputfile)
path='./ass2_mal_json/API_invoke_methods'+'.json'
with open(path, 'r') as inputfile:
    API_invoke_methods_m=json.load(inputfile)
path='./ass2_mal_json/app_API'+'.json'
with open(path, 'r') as inputfile:
    app_API_m=json.load(inputfile)
path='./ass2_mal_json/API_codeblocks'+'.json'
with open(path, 'r') as inputfile:
    API_codeblocks_m=json.load(inputfile)  
path='./ass2_mal_json/all_API'+'.json'
with open(path, 'r') as inputfile:
    all_API_m=json.load(inputfile)


# In[3]:


def get_I(API_invoke_methods, all_API):
    invoke_methods=list(API_invoke_methods.keys())
    df=pd.DataFrame(0, columns=invoke_methods, index=all_API)
    for method in invoke_methods:
        df.loc[API_invoke_methods[method], method]+=1
    return df


# In[4]:


I=get_I(API_invoke_methods, all_API)


# In[5]:


I.head()


# In[12]:


def get_A(all_API, app_API):
    app_api_df=pd.DataFrame({'app': list(app_API.keys()), 'api list': list(app_API.values())})
    mlb = MultiLabelBinarizer()
    mlb.fit([all_API])
    one_hot=mlb.transform(app_api_df['api list'])
    A=pd.DataFrame(index=list(app_API.keys()), columns=all_API, data=one_hot)
    return A


# In[13]:


A=get_A(all_API,app_API)
A.shape


# In[87]:


def get_AAT(all_API, app_API):
    A=get_A(all_API, app_API)
    sparse_A=sparse.csr_matrix(A.values)
    AAT_value=sparse_A.dot(sparse_A.T).todense()
    all_app=list(app_API.keys())
    AAT=pd.DataFrame(index=all_app, columns=all_app, data=AAT_value)
    return AAT


# In[88]:


AAT=get_AAT(all_API, app_API)


# In[89]:


AAT


# In[7]:


def get_B(API_codeblocks, all_API):
    two_more=[x for x in API_codeblocks if len(x)>=2]
    print(len(two_more))
    mlb = MultiLabelBinarizer()
    mlb.fit([all_API])
    one_hot=mlb.transform(two_more)
    codeblock_df_t=pd.DataFrame(index=range(len(two_more)), columns=all_API, data=one_hot)
    print(codeblock_df_t.shape)
    sparse_t=sparse.csr_matrix(codeblock_df_t.values)
    df_data=sparse_t.T.dot(sparse_t).todense()
    print(df_data.shape)
    B=pd.DataFrame(index=all_API, columns=all_API, data=df_data)
    return B


# In[8]:


B=get_B(API_codeblocks, all_API)


# In[9]:


B.head()


# In[39]:


def get_P(API_package, all_API):
    mlb = MultiLabelBinarizer()
    mlb.fit([all_API])
    one_hot=mlb.transform(list(API_package.values()))
    df_t=pd.DataFrame(columns=all_API, index=list(API_package.keys()), data=one_hot)
    sparse_t=sparse.csr_matrix(df_t.values)
    df_data=sparse_t.T.dot(sparse_t).todense()
    P=pd.DataFrame(index=all_API, columns=all_API, data=df_data)
    return P


# In[15]:


P=get_P(API_package, all_API)


# In[17]:


P.head()


# In[ ]:





# In[93]:


info=AAT.stack()[AAT.stack()>0]
df=info.to_frame('value').reset_index()
df                                  


# In[94]:


df.level_0.tolist()


# In[95]:


G=nx.from_pandas_edgelist(df, 'level_0','level_1', ['value'])


# In[99]:


Gr=nx.draw(G)


# In[ ]:





# In[68]:


def draw_graph(matrix):
    s=matrix.stack()[matrix.stack()>0]
    df=s.to_frame('value').reset_index()
    G=nx.from_pandas_edgelist(df, 'level_0','level_1', ['value'])
    nx.draw(G)
    return G


# In[69]:


def graph_stats(G):
    density = nx.density(G)
    corr = nx.degree_pearson_correlation_coefficient(G)
    avg_neighbor_degree = nx.average_neighbor_degree(G) #dict
    k_nearest_neighbors = nx.k_nearest_neighbors(G) #dict
    degree_centrality = nx.degree_centrality(G) #dict
    info = nx.info(G)
    return {'density':density,'corr':corr,'avg_neighbor_degree':avg_neighbor_degree,
           'k_nearest_neighbors':k_nearest_neighbors,'degree_centrality':degree_centrality,'info':info}


# In[70]:


G_ABAT=draw_graph(ABAT)


# In[72]:


stars_ABAT=graph_stats(G_ABAT)
stars_ABAT


# In[34]:


def get_ABAT(API_codeblocks, all_API, app_API):
    all_app=list(app_API.keys())
    A_values=get_A(all_API, app_API).values
    B_values=get_B(API_codeblocks, all_API).values
    sparse_A=sparse.csr_matrix(A_values)
    sparse_B=sparse.csr_matrix(B_values)
    sparse_B[sparse_B>0]=1
    result=sparse_A.dot(sparse_B).dot(sparse_A.T).todense()
    ABAT=pd.DataFrame(index=all_app, columns=all_app, data=result)
    return ABAT


# In[35]:


ABAT=get_ABAT(API_codeblocks, all_API, app_API)


# In[36]:


ABAT


# In[14]:


A_values=A.values


# In[15]:


sparse_A=sparse.csr_matrix(A_values)


# In[29]:


result=sparse_A.dot(sparse_B).dot(sparse_A.T).todense()


# In[30]:


result


# In[37]:


def get_APAT(API_package, all_API, app_API):
    all_app=list(app_API.keys())
    A_values=get_A(all_API, app_API).values
    P_values=get_P(API_package, all_API).values
    sparse_A=sparse.csr_matrix(A_values)
    sparse_P=sparse.csr_matrix(P_values)
    result=sparse_A.dot(sparse_P).dot(sparse_A.T).todense()
    APAT=pd.DataFrame(index=all_app, columns=all_app, data=result)
    return APAT
    
    
    


# In[54]:


p=get_P(API_package, all_API)


# In[ ]:





# In[40]:


APAT=get_APAT(API_package, all_API, app_API)


# In[42]:


APAT.values


# In[43]:


sparse_A=sparse.csr_matrix(A_values)


# In[45]:


A.describe()


# In[ ]:





# In[62]:


def get_APBPTAT(all_API, app_API, API_package, API_codeblocks):
    all_app=list(app_API.keys())
    A_values=get_A(all_API, app_API).values
    P_values=get_P(API_package, all_API).values
    B_values=get_B(API_codeblocks, all_API).values
    sparse_A=sparse.csr_matrix(A_values)
    sparse_P=sparse.csr_matrix(P_values)
    sparse_P[sparse_P>0]=1
    sparse_B=sparse.csr_matrix(B_values)
    sparse_B[sparse_B>0]=1
    
    result=sparse_A.dot(sparse_P).dot(sparse_B).dot(sparse_P.T).dot(sparse_A.T).todense()
    APBPTAT=pd.DataFrame(index=all_app, columns=all_app, data=result)
    return APBPTAT


# In[63]:


APBPTAT=get_APBPTAT(all_API, app_API, API_package, API_codeblocks)


# In[64]:


APBPTAT.head()


# In[ ]:





# Statistically describe the set of applications you have collected. This is will require defining your own relevant statistics (e.g. number of classes/app, most common library used, graph-degree related statistics) to investigate and understand the population of apps that you've downloaded. In particular, you should look at how these statistics differ across two relevant classes of apps (this may be one-app-type vs another-app-type; malware vs benign).

# In[85]:


package_info=pd.DataFrame(index=API_package.keys(), data=[len(API_package[x]) for x in API_package], columns=['count'])


# In[92]:


most_common_package=package_info.sort_values(by=['count'],ascending=False).iloc[:10]
most_common_package


# In[ ]:





# In[ ]:





# In[ ]:




